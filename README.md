# 介绍
一个简单的类unix内核，目前准备支持x86和arm架构，其中arm目标支持平台是raspi2b。在本系列文章中主要用arm的代码作为例子，原因是x86架构有较重的历史负担导致编码异常困难，但是x86部分我也差不多写了个大概，两者代码会考虑的。主要参考已有的类unix内核，xv6/FreeNOS/linux，重写一个通用的类unix的内核，并且提供一个最小根目录文件系统，验证可行性。

选择x86和raspi2b的另一个重要原因是qemu支持模拟这两种硬件型号，降低对实际物理硬件的依赖和调试难度。

# 局限
* 目前仅在qemu上开发，但 **不确保** 实际硬件机器上也能正常工作。
* 由于时间精力以及能力有限，目前的实现 **仅支持32位**，即使是arm也仅使用a32指令集。
* **仅支持单核**，多核与单核相比多的是一系列并发处理上的问题，不影响整体框架。后续若是有精力再单独讨论smp相关的实现。
* 无论是内存管理还是其他的基本采用最简单的实现方式，但会提供接口以供他人编写出更酷的实现方式。
* BootLoader目前没有计划考虑支持。
* 驱动支持列表少。

# 路线图
* 0. 工具链 && 编译环境搭建 - 已完成
* 1. 启动 - 已完成（单核）
* 2. 内存管理 - 已完成
    - 1. 内存布局
    - 2. 虚拟地址映射
    - 3. 内存分配管理
        - 1.内核空间
        - 2.用户空间
* 3. 中断管理 - 已完成
    - 1. 中断服务例程
    - 2. 中断`API`
    - 3. 系统调用
* 4. 驱动 - 已完成
    - 1. 存储管理器 `IDE(x86)/eMMC(raspi2b)`
    - 2. 串口（`x86`可选，`raspi2b`必选）
    - 3. 键盘（`x86`可选）
* 5. 进程管理 - 已完成
    - 1. 第一个进程`init`
    - 2. 调度
* 6. 文件系统 - 已完成
    - 1.索引式文件系统（必选）
    - 2.FAT式文件系统（可选，并且支持力度不够，不必强行兼容）
* 7. 系统调用 - 已完成
    - 1. 文件系统相关
    - 2. 进程调度相关

目前已经能正常运行，后续看有时间再添加时钟中断，多核等等支持。此项目没必要继续做大，深挖还不如现成的linux内核。

# 运行说明

以`raspi2b为例`，执行以下命令：
```
. set_raspi2b.sh
make
make xv6.img
make qemu
```

# 整体架构
整体框架参考`linux`，分别为内存管理，文件系统，进程管理，中断，驱动。

# 代码目录

整体代码目录参考`linux`。

# 版权许可证补充说明
由于参考借鉴，或者直接拷贝相关的代码片段，所以相关版权协议我也想不太明白。目前已知相关代码有xv6使用的MIT许可证，linux使用的GPL许可证

# FAQ

## 为什么使用宏内核而不是微内核？
我个人开发上对宏内核更加熟悉，并且使用宏内核有助于理解`linux`的设计和实现。如果对微内核有兴趣不妨去看一下[FreeNOS](http://www.freenos.org/)?

## 为什么使用C语言而不是别的更为高级语言（C++/Go/Rust）？
其他高级语言都极大程度屏蔽底层硬件的差异性，并且或多或少有运行时支持（在裸机上需要自己实现这些运行时支持的接口）。可以这么认为，在内核编程方面，其他高级语言除了语法糖好看一点之外，和C语言并没有更多可取之处，而后者对硬件的表达能力更强。作为一个玩具级别的内核，没必要折腾高级语言。

## IDE？
看个人选择，我是在ubuntu20.04下做开发的，所以选择的是vim + coc + clangd-12。windows下选择也挺多的，此外轻量级一点的vscode也不错。
